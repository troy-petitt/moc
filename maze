// Assignment 10
// CS 2510 Spring 2015
// Mews-Schmuck Nicolas
// nic
// Petitt Troy
// troyp95

import java.util.*;
import tester.*;
import javalib.impworld.*;
import javalib.colors.*;
import javalib.worldimages.*;

// A comparator for cell edges by weight
class CellEdgeWeightComp implements Comparator<CellEdge> {
    // Returns 0 if edge1 and edge2 have the same weight
    // Returns an int < 0 if edge1 comes before edge2
    // Returns an int > 0 if edge1 comes after edge2
    public int compare(CellEdge edge1, CellEdge edge2) {
        return edge1.weight - edge2.weight;
    }
}

// Represents the maze game
class MazeWorld extends World {
    // The width of the maze in cells
    static final int MAZE_WIDTH = 100;
    // The height of the maze in cells
    static final int MAZE_HEIGHT = 60;
    // The size of each cell in pixels
    static final int CELL_SIZE = 10;
    
    ArrayList<ArrayList<Cell>> maze;
    Player player;
    Random rand;
    boolean consMaze;
    
    ICollection<Cell> worklist;
    ArrayList<Cell> alreadySeen;
    
    
    MazeWorld() {
        this.rand = new Random();
        consMaze = true;
        this.maze = this.generateMaze();
        this.alreadySeen = new ArrayList<Cell>();
        this.player = new Player(this.maze.get(0).get(0));
    }
    // Draw the maze
    public WorldImage makeImage() {
        WorldImage bg = new RectangleImage(
                new Posn((MazeWorld.MAZE_WIDTH + 1) / 2 * MazeWorld.CELL_SIZE,
                        (MazeWorld.MAZE_HEIGHT + 1) / 2 * MazeWorld.CELL_SIZE),
                        MazeWorld.MAZE_WIDTH * MazeWorld.CELL_SIZE,
                        MazeWorld.MAZE_HEIGHT * MazeWorld.CELL_SIZE,
                        new White());
        for (ArrayList<Cell> row : this.maze) {
            for (Cell cell : row) {
                bg = bg.overlayImages(cell.drawCell());
            }
        }
        return bg;
    }
    // Generate a maze using Kruskal's algorithm
    ArrayList<ArrayList<Cell>> generateMaze() {
        ArrayList<ArrayList<Cell>> nodes = this.initializeCells();
        ArrayList<CellEdge> edges = this.initializeEdges(nodes);
        
        edges = this.getMinSpanningTree(edges, nodes);
        for (CellEdge edge : edges) {
            edge.from.addUndirectedEdge(edge);
        }
        return nodes;
    }
    
    // Returns a 2-D list of unconnected cells
    ArrayList<ArrayList<Cell>> initializeCells() {
        ArrayList<ArrayList<Cell>> cells = new ArrayList<ArrayList<Cell>>();
        for (int i = 0; i < MazeWorld.MAZE_HEIGHT; i += 1) {
            ArrayList<Cell> row = new ArrayList<Cell>();
            for (int j = 0; j < MazeWorld.MAZE_WIDTH; j += 1) {
                row.add(new Cell(j, i));
            }
            cells.add(row);
        }
        return cells;
    }
    // Returns a list of edges with random weights between
    // each cell in the given 2-D list of cells and its top and left neighbors
    ArrayList<CellEdge> initializeEdges(ArrayList<ArrayList<Cell>> cells) {
        ArrayList<CellEdge> edges = new ArrayList<CellEdge>();
        for (int i = 0; i < MazeWorld.MAZE_HEIGHT; i += 1) {
            for (int j = 0; j < MazeWorld.MAZE_WIDTH; j += 1) {
                Cell curCell = cells.get(i).get(j);
                if (i > 0) {
                    edges.add(new CellEdge(curCell, 
                                    cells.get(i - 1).get(j),
                                    this.rand.nextInt(100)));
                }
                if (j > 0) {
                    edges.add(new CellEdge(curCell, 
                                    cells.get(i).get(j - 1),
                                    this.rand.nextInt(100)));
                }
            }
        }
        return edges;
    }
    // Returns a list of edges generated by applying Kruskal's algorithm to
    // the given list of edges based on the given 2-D list of nodes
    ArrayList<CellEdge> getMinSpanningTree(ArrayList<CellEdge> edges, ArrayList<ArrayList<Cell>> nodes) {
        ArrayList<CellEdge> edgesInTree = new ArrayList<CellEdge>();
        // Initialize the HashMap
        UnionFind<Cell> rep = new UnionFind<Cell>();
        for (ArrayList<Cell> row : nodes) {
            for (Cell node : row) {
                rep.set(node, node);
            }
        }
        Collections.sort(edges, new CellEdgeWeightComp());
        for (CellEdge edge : edges) {
            if (edgesInTree.size() + 1 == MazeWorld.MAZE_HEIGHT * MazeWorld.MAZE_WIDTH) {
                return edgesInTree;
            }
            Cell fromRep = rep.find(edge.from);
            Cell toRep = rep.find(edge.to);
            if (fromRep == toRep) {
                // Do nothing
            }
            else {
                edgesInTree.add(edge);
                rep.set(fromRep, toRep);
            }
        }
        return edgesInTree;
    }
    // Colors the correct path based on this world's 
    // alreadySeen list generated by the search algorithm
    // EFFECT: modifies this.maze
    void correctPath() {
        Cell curCell = this.alreadySeen.get(this.alreadySeen.size() - 1);
        curCell.correctPath = true;
        for (int i = this.alreadySeen.size() - 2; i >= 0; i -= 1) {
            Cell next = this.alreadySeen.get(i);
            for (CellEdge edge : curCell.outEdges) {
                if (edge.to == next) {
                    curCell = next;
                    curCell.correctPath = true;
                    break;
                }
            }
        }
    }
    // Updates the world on each tick
    // EFFECT: may modify this.alreadySeen and this.worklist
    //  and any cells in this.worklist or this.alreadySeen
    public void onTick() {
        if (this.player.loc.x == this.maze.get(0).size() - 1 &&
            this.player.loc.y == this.maze.size() - 1) {
            
        }
        if (this.worklist != null) {
            Cell next = worklist.remove();
            next.traversed = true;
            if (next == this.maze.get(this.maze.size() - 1).get(this.maze.get(0).size() - 1)) {
                this.alreadySeen.add(next);
                this.correctPath();
                this.worklist = null;
//                this.stopWorld();
            }
            else {
                this.alreadySeen.add(next);
                for (CellEdge e : next.outEdges) {
                    if (!this.alreadySeen.contains(e.to)) {
                        this.worklist.add(e.to);
                    }
                }
            }
        }
    }
    // TODO
    public void onKeyEvent(String key) {
        if (key.equals("b")) {
            this.worklist = new Queue<Cell>();
            this.worklist.add(this.maze.get(0).get(0));
        }
        else if (key.equals("d")) {
            this.worklist = new Stack<Cell>();
            this.worklist.add(this.maze.get(0).get(0));
        }
        else if (key.equals("r")) {
            this.worklist = null;
            this.alreadySeen = new ArrayList<Cell>();
            this.rand = new Random();
            this.maze = this.generateMaze();
            this.player = new Player(this.maze.get(0).get(0));
            this.alreadySeen = new ArrayList<Cell>();
        }
        else if (key.equals("up")) {
            this.player.moveUp();
        }
        else if (key.equals("right")) {
            this.player.moveRight();
        }
        else if (key.equals("down")) {
            this.player.moveDown();
        }
        else if (key.equals("left")) {
            this.player.moveLeft();
        }
    }
}

class ExamplesMaze {
    MazeWorld mw;
    ExamplesCell ec;
    ArrayList<ArrayList<Cell>> maze;
    
    void initialize() {
        this.mw = new MazeWorld();
        ec = new ExamplesCell();
        ec.initialize();
        maze = new ArrayList<ArrayList<Cell>>();
        ArrayList<Cell> row1 = new ArrayList<Cell>();
        ArrayList<Cell> row2 = new ArrayList<Cell>();
        ArrayList<Cell> row3 = new ArrayList<Cell>();
        row1.addAll(Arrays.asList(ec.c1, ec.c2, ec.c3));
        row2.addAll(Arrays.asList(ec.c4, ec.c5, ec.c6));
        row3.addAll(Arrays.asList(ec.c7, ec.c8, ec.c9));
        maze.addAll(Arrays.asList(row1, row2, row3));
    }
    void testBigBang(Tester t) {
        MazeWorld mw = new MazeWorld();
        mw.bigBang(MazeWorld.MAZE_WIDTH * MazeWorld.CELL_SIZE,
                   MazeWorld.MAZE_HEIGHT * MazeWorld.CELL_SIZE,
                   0.001);
    }
    
    void testCellEdgeWeightComp(Tester t) {
        CellEdge e1 = new CellEdge(new Cell(0, 0), new Cell(1, 0), 5);
        CellEdge e2 = new CellEdge(new Cell(2, 1), new Cell(0, 3), 5);
        CellEdge e3 = new CellEdge(new Cell(2, 3), new Cell(9, 8), 4);
        CellEdge e4 = new CellEdge(new Cell(1, 1), new Cell(7, 3), 6);
        CellEdgeWeightComp cewc = new CellEdgeWeightComp();
        t.checkExpect(cewc.compare(e1, e2) == 0, true);
        t.checkExpect(cewc.compare(e1, e3) > 0, true);
        t.checkExpect(cewc.compare(e1, e4) < 0, true);
    }
    void testMakeImage(Tester t) {
        this.initialize();
        this.mw.maze = maze;

        WorldImage mazeBg = new RectangleImage(new Posn(500, 300), 1000, 600, new White());
        WorldImage mazeImg = mazeBg.overlayImages(
                ec.c1Img).overlayImages(
                ec.c2Img).overlayImages(
                ec.c3Img).overlayImages(
                ec.c4Img).overlayImages(
                ec.c5Img).overlayImages(
                ec.c6Img).overlayImages(
                ec.c7Img).overlayImages(
                ec.c8Img).overlayImages(
                ec.c9Img);
        t.checkExpect(this.mw.makeImage(), mazeImg);
    }
    void testInitializeCells(Tester t) {
        this.initialize();
        ArrayList<ArrayList<Cell>> temp = this.mw.initializeCells();
        t.checkExpect(temp.get(0).size(), 100);
        t.checkExpect(temp.size(), 60);
        t.checkExpect(temp.get(0).get(0).x, 0);
        t.checkExpect(temp.get(0).get(0).y, 0);
        t.checkExpect(temp.get(15).get(20).x, 20);
        t.checkExpect(temp.get(23).get(12).y, 23);
    }
    void testInitializeEdges(Tester t) {
        this.initialize();
        this.mw.rand = new Random(14);
        ArrayList<ArrayList<Cell>> cells = this.mw.initializeCells();
        ArrayList<CellEdge> edges = this.mw.initializeEdges(cells);
        
        t.checkExpect(edges.size(), 11840);
        t.checkExpect(edges.get(0), new CellEdge(cells.get(0).get(1),
                                                 cells.get(0).get(0),
                                                 15));
        t.checkExpect(edges.get(1), new CellEdge(cells.get(0).get(2),
                                                 cells.get(0).get(1),
                                                 84));
        t.checkExpect(edges.get(201), new CellEdge(cells.get(1).get(51),
                                                   cells.get(1).get(50),
                                                   92));
        t.checkExpect(edges.get(202), new CellEdge(cells.get(1).get(52),
                                                   cells.get(0).get(52),
                                                   3));
    }
    void testGetMinSpanningTree(Tester t) {
        this.initialize();
        
        ArrayList<CellEdge> testEdges = new ArrayList<CellEdge>();
        testEdges.addAll(Arrays.asList(
                new CellEdge(ec.c2, ec.c3, 51), new CellEdge(ec.c7, ec.c9, 14),
                new CellEdge(ec.c9, ec.c1, 3), new CellEdge(ec.c8, ec.c7, 29),
                new CellEdge(ec.c8, ec.c6, 54), new CellEdge(ec.c8, ec.c8, 67),
                new CellEdge(ec.c4, ec.c1, 63), new CellEdge(ec.c5, ec.c7, 26),
                new CellEdge(ec.c7, ec.c2, 9), new CellEdge(ec.c1, ec.c2, 29),
                new CellEdge(ec.c5, ec.c2, 10), new CellEdge(ec.c8, ec.c6, 87),
                new CellEdge(ec.c4, ec.c1, 0), new CellEdge(ec.c9, ec.c3, 11),
                new CellEdge(ec.c7, ec.c4, 13), new CellEdge(ec.c1, ec.c2, 19),
                new CellEdge(ec.c2, ec.c8, 59), new CellEdge(ec.c8, ec.c9, 17)));
        ArrayList<CellEdge> expectedEdges = new ArrayList<CellEdge>();
        expectedEdges.addAll(Arrays.asList(
                new CellEdge(ec.c4, ec.c1, 0), new CellEdge(ec.c9, ec.c1, 3),
                new CellEdge(ec.c7, ec.c2, 9), new CellEdge(ec.c5, ec.c2, 10),
                new CellEdge(ec.c9, ec.c3, 11), new CellEdge(ec.c7, ec.c4, 13),
                new CellEdge(ec.c8, ec.c9, 17), new CellEdge(ec.c8, ec.c6, 54)));
        t.checkExpect(this.mw.getMinSpanningTree(testEdges, this.maze), expectedEdges);
    }
    void testGenerateMaze(Tester t) {
        this.initialize();
        this.mw.rand = new Random(14);
        
        ArrayList<ArrayList<Cell>> actualMaze = this.mw.generateMaze();
        t.checkExpect(actualMaze.size(), 60);
        t.checkExpect(actualMaze.get(0).size(), 100);
        t.checkExpect(actualMaze.get(0).get(22).x, 22);
        t.checkExpect(actualMaze.get(13).get(42).y, 13);
        t.checkExpect(actualMaze.get(0).get(1).outEdges.get(0).weight, 15);
        t.checkExpect(actualMaze.get(0).get(1).outEdges.get(0).to == actualMaze.get(0).get(0));
        t.checkExpect(actualMaze.get(0).get(0).outEdges.get(0).weight, 15);
        t.checkExpect(actualMaze.get(0).get(0).outEdges.get(0).to == actualMaze.get(0).get(1));
        t.checkExpect(actualMaze.get(1).get(52).outEdges.get(0).weight, 3);
        t.checkExpect(actualMaze.get(1).get(52).outEdges.get(0).to == actualMaze.get(0).get(52));
        t.checkExpect(actualMaze.get(0).get(52).outEdges.get(0).weight, 3);
        t.checkExpect(actualMaze.get(0).get(52).outEdges.get(0).to == actualMaze.get(1).get(52));
    }
    void testCorrectPath(Tester t) {
        this.initialize();
        // Make the Examples Cells edges undirected
        this.ec.c3.correctPath = false;
        this.ec.c4.addEdge(new CellEdge(this.ec.c4, this.ec.c1, 10));
        this.ec.c6.outEdges.remove(0); // Remove the edge to c3
        this.ec.c6.addEdge(new CellEdge(this.ec.c6, this.ec.c5, 10));
        this.ec.c9.addEdge(new CellEdge(this.ec.c9, this.ec.c6, 10));
        this.mw.alreadySeen = new ArrayList<Cell>();
        this.mw.alreadySeen.addAll(Arrays.asList(
                this.ec.c1, this.ec.c4, this.ec.c5,
                this.ec.c2, this.ec.c3, this.ec.c6,
                this.ec.c9));
        this.mw.correctPath();
        t.checkExpect(this.ec.c1.correctPath, true);
        t.checkExpect(this.ec.c2.correctPath, false);
        t.checkExpect(this.ec.c3.correctPath, false);
        t.checkExpect(this.ec.c4.correctPath, true);
        t.checkExpect(this.ec.c5.correctPath, true);
        t.checkExpect(this.ec.c6.correctPath, true);
        t.checkExpect(this.ec.c7.correctPath, false);
        t.checkExpect(this.ec.c8.correctPath, false);
        t.checkExpect(this.ec.c9.correctPath, true);
    }
    void testOnTick(Tester t) {
        this.initialize();
        //TODO Troy
        
    }
    void testOnKeyEvent(Tester t) {
        this.initialize();
        //this.mw.worldEnds();
        ArrayList<ArrayList<Cell>> oldMaze = this.mw.maze;
        Random oldRand = this.mw.rand;
        this.mw.onKeyEvent("r");
        t.checkExpect(this.mw.maze != oldMaze, true);
        t.checkExpect(this.mw.rand != oldRand, true);
        t.checkExpect(this.mw.worklist, null);
        this.mw.onKeyEvent("b");
        t.checkExpect(this.mw.worklist.isEmpty(), false);
        Cell bStart = this.mw.worklist.remove();
        t.checkExpect(bStart.x, 0);
        t.checkExpect(bStart.y, 0);
        t.checkExpect(bStart.traversed, false);
        t.checkExpect(bStart.correctPath, false);
        this.mw.onKeyEvent("d");
        t.checkExpect(this.mw.worklist.isEmpty(), false);
        Cell dStart = this.mw.worklist.remove();
        t.checkExpect(dStart.x, 0);
        t.checkExpect(dStart.y, 0);
        t.checkExpect(dStart.traversed, false);
        t.checkExpect(dStart.correctPath, false);
    }
}
